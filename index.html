<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">

  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">

  <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="styles/highlight.css">
  <link rel="stylesheet" href="styles/main.css">

  <title>Beanmapper by 42BV</title>
</head>

<body>

<header class="container-fluid">
  <div class="row">
    <div class="col-xs-12">
      <img src="images/logo.png" alt="Logo BeanMapper" class="logo">
      <h1>Beanmapper</h1>
      <h2>Library for converting from one Java class to a dissimilar Java class <br>with similar names based on the Bean
        convention</h2>

      <a href="https://github.com/42BV/beanmapper/zipball/master" class="btn">Download as .zip</a>
      <a href="https://github.com/42BV/beanmapper/tarball/master" class="btn">Download as .tar.gz</a>
      <a href="https://github.com/42BV/beanmapper" class="btn" target="_blank">View on GitHub</a>
    </div>
  </div>
</header>

<div class="container-fluid content">
  <div class="row">
    <div class="col-md-offset-1 col-xs-12 col-sm-9 col-md-7">
      <!-- BeanMapper -->
      <section id="about">
        <h3 class="section-title">What is BeanMapper?</h3>
        <div class="section-body">
          The core definition of the task of BeanMapper is for converting from one Java class to a dissimilar Java class with similar names based on the Bean convention.
          However BeanMapper does have a lot more functionality than only converting Java classes.<br>
          You can read about this in the rest of the documentation.<br>
          <br>
          Using Spring?<br>
          Take a look at <a href="https://github.com/42BV/beanmapper-spring" target="_blank">BeanMapper-Spring</a> for combining the power of BeanMapper together with Spring.<br>
          <br>
          Take a look at the <a href="https://github.com/42BV/beanmapper-petshop" target="_blank">BeanMapper-Petshop</a> for samples of using BeanMapper.
          It shows you how to use the BeanMapper in a REST API in Java.
          It also show examples of using BeanMapper in combination with BeanMapper-Spring
        </div>
      </section>
      <section id="use-case">
        <h3 class="section-title">Why using BeanMapper?</h3>
        <div class="section-body">
         When building a REST API you work quite often with three kinds of objects.
          <ol>
            <li>The Entity; The entity represents the data inside the application.</li>
            <li>The Result; The result represents the entity to the outside of the world. This could be a partially entity.</li>
            <li>The Form; When creating/updating a entity you often want to use a form object to pass the given data to.</li>
          </ol>
          Below a image showing this three objects in context of the application: <br>
          <a href="/images/beanmapper-usecase.png" target="_blank"><img src="images/beanmapper-usecase.png" height="200px"></a><br>

          <b>Why using forms?</b>
          <ul>
            <li>For security reasons you want to accept only a limited number of fields as input.</li>
            <li>The form fields are simplified to support frontend processing.</li>
          </ul>

          <b>Why using results?</b>
          <ul>
            <li>You want to simplify the result for frontend processing.</li>
            <li>You want to expose a limited number of fields for security reasons.</li>
          </ul>

          When using these three kinds of objects you want to convert incoming data to your entity. You also want to convert your entity to a result when representing data to the outside.
          These conversions will cost a lot of unnecessary code.<br>
          <br>
          <b>Wouldn't it be great if mapping from Form to Entity and from Entity to Result can be done automatically?</b><br>
          Let us suppose we have a tool that is able to map similar fields from dissimilar classes.<br>
          In this case, it would be just a matter of passing both instances and delegating the task of mapping from source to target to this tool.<br>
          This is why you should BeanMapper; BeanMapper just does the above described problem in a very easy way.<br>
          Want to use BeanMapper? In the <a href="#how-to-use">next section</a>  you can read about using BeanMapper.<br>
          <br>
          For a more detailed use case of why using BeanMapper,
          read this blog <a href="http://dontpanic.42.nl/2016/02/the-case-for-beanmapper.html" target="_blank">'The Case for BeanMapper'</a>.<br>
        </div>
      </section>
      <section id="how-to-use">
        <h3 class="section-title">How to Use</h3>
        <div class="section-body">
          You can convert your objects on four different ways.
          <ol>
            <li>convert to a new class</li>
            <li>convert to a existing instance</li>
            <li>convert to a collection</li>
            <li>convert to a dynamic generated class</li>
          </ol>
          Below a basic sample of each way of converting. These samples only show a basic conversion.
          You should take a look at the rest of the documentation if you want to map some different fields or a map a different structure.<br>
          <br>
          Lets assume that we have two classes. SourceClass is your entity that is used inside the application.
          TargetClass is the class that you would like to expose to the outside.<br>
          <br>
<code>
public class Source {
    public Long id;
    public String name;
    public Integer age;

    public Source(Long id, String name, Integer age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}

public class Target {
    public String name;
    public Integer age;
}
</code>

          <br><b>Map to a new class</b><br>
          Mapping to a new class does first create an instance of the given target class.<br>
          Then BeanMapper uses the map to existing instance strategy to map the source to the created class instance.<br>
          Take a look at <a href="#beanconstruct">BeanConstruct</a>  if you do not have a non-args constructor.<br>
          <br>
<code>
Source source = new Source(1L, "Henk", 42);

Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals("Henk", target.name);
assertEquals(42, target.age, 0);
</code>

          <br><b>Map to a existing instance</b><br>
          Use this method if you want to override a instance with another instance.<br>
          The values of the target instance are overwritten by the given source instance.<br>
          Fields are mapped base on the name of the field and based on bean conventions.
          BeanMapper only maps fields when a field name in the source instance matches a field name in the target instance.<br>
          With annotations you have a lot more possibilities to map classes, take a look on the list below.<br>
          <br>
          <table class="table table-condensed">
            <tr>
              <th>BeanIgnore</th>
              <td>Use this when you explicitly don't want to map a field.</td>
              <td><a href="#beanignore">docs</a></td>
            </tr>
            <tr>
              <th>BeanProperty</th>
              <td>Use this when you want to map fields that have no matching field names.</td>
              <td><a href="#beanproperty">docs</a></td>
            </tr>
            <tr>
              <th>BeanDefault</th>
              <td>Use this when you want to set a default value when the mapped value is null.</td>
              <td><a href="#beandefault">docs</a></td>
            </tr>
            <tr>
              <th>BeanCollection</th>
              <td>Use this when you want to map a field of type Collection.</td>
              <td><a href="#beancollection">docs</a></td>
            </tr>
          </table>
<code>
Source source = new Source(1L, "Henk", 42);

Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals("Henk", target.name);
assertEquals(42, target.age, 0);
</code>
          <br><b>Map to a collection</b><br>
          Use this method when you want to map a collection of items to a collection of items of an other type.<br>
          Of course you can do this for yourself by creating a loop and call map inside each loop.
          This method is just to make it easy for you.
          Can also pass a third optional argument to convert the list to. In this case we choose a ArrayList.class.<br>
          <br>
<code>
List&lt;Source> sources = new ArrayList&lt;Source>();
sources.add(new Source(1L, "Henk", 42));
sources.add(new Source(2L, "Piet", 50));
sources.add(new Source(3L, "Kees", 3));

ArrayList&lt;Target> targets = (ArrayList&lt;Target>) new BeanMapperBuilder().build()
        .map(sources, Target.class, ArrayList.class);

assertEquals(3, targets.size(), 0);
assertEquals("Henk", targets.get(0).name);
assertEquals("Piet", targets.get(1).name);
assertEquals("Kees", targets.get(2).name);
</code>
          <br><b>Convert to a dynamic generated class</b><br>
          This method consist of two different ways:
          <ol>
            <li>Map only a few fields of the source class over the existing target instance.</li>
            <li>Map to a new target instance and restrict this target instance to contain only the given fields.</li>
          </ol>
          Both methods does use javassist to create a new class.
          <br><br>
          The first option is called 'downsizeSource'.
          This method generates a new class based on the source class but only with the fields you want to map.
          BeanMapper uses the generated class to map over the existing given target instance.
          The result is that you have mapped only a few fields from the source over the target instance.
          Use case for this method is for example a <a href="#patch">PATCH request</a>.
          <br><br>
          The second options is called 'downsizeTarget'.
          With this option you can expose a few fields of the source class to the outside.
          BeanMapper generates a new class based on the given target class but only with the fields you want to exist in the target.
          <br><br>
          Below examples of both options.
<code>
// Option 1: downsizeSource
BeanMapper beanMapper = new BeanMapperBuilder().build();
Source source = new Source(1L, "Henk", 42);
Target target = new Target("Piet", 12);

beanMapper.wrapConfig()
        .downsizeSource(Arrays.asList("age"))
        .build()
        .map(source, target);

assertEquals("Piet", target.name);
assertEquals(42, target.age, 0);

// Option 2: downsizeTarget
BeanMapper beanMapper = new BeanMapperBuilder().build();
Source source = new Source(1L, "Henk", 42);

Object target = beanMapper.wrapConfig()
        .downsizeTarget(Arrays.asList("name"))
        .build()
        .map(source, Target.class);

String json = new ObjectMapper().writeValueAsString(target);
assertEquals("{\"name\":\"Henk\"}", json);
</code>
        </div>
      </section>
      <section id="download">
        <h3 class="section-title">Download</h3>
        <div class="section-body">
          In order to use Beanmapper in your project, simple add the following Maven dependency.<br>
<code>
  &lt;dependency&gt;
      &lt;groupId&gt;io.beanmapper&lt;/groupId&gt;
      &lt;artifactId&gt;beanmapper&lt;/artifactId&gt;
      &lt;version&gt;{{version}}&lt;/version&gt;
  &lt;/dependency&gt;
</code>
          <br>
          Version is the latest version of BeanMapper
          <a href="https://maven-badges.herokuapp.com/maven-central/io.beanmapper/beanmapper" target="_blank"><img src="https://maven-badges.herokuapp.com/maven-central/io.beanmapper/beanmapper/badge.svg"></a><br>
          <br>
          You can find the javadoc for BeanMapper <a href="http://www.javadoc.io/doc/io.beanmapper/beanmapper" target="_blank">here</a>.<br>
          You can also download the <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?g=io.beanmapper&a=beanmapper&v=LATEST&r=central-proxy"> latest jar </a> and include this in your project.
        </div>
      </section>

      <!-- Annotations -->
      <section id="beanproperty">
        <h3 class="section-title">BeanProperty</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanProperty</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Name: the name that matches the field name on the other side</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>Use BeanProperty if the field name does not match the other field name.
                  You can use this annotation on both sides.
              </td>
            </tr>
            <tr>
              <th>Exceptions</th>
              <td>BeanNoSuchPropertyException is thrown when BeanMapper can not find a field with the given name</td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Source {
    public Long id;
    public String name;
    @BeanProperty(name = "otherAge")
    public Integer age;
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
public class Target {
    @BeanProperty(name = "name")
    public String otherName;
    public Integer otherAge;
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Source source = new Source(1L, "Henk", 42);
Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals("Henk", target.otherName);
assertEquals(42, target.otherAge, 0);
</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beanignore">
        <h3 class="section-title">BeanIgnore</h3>
        <div class="section-body">
		  <table class="table table-condensed">
			<tr>
			  <th>Annotation</th>
			  <td>@BeanIgnore</td>
			</tr>
			<tr>
			  <th>Arguments</th>
			  <td>None</td>
			</tr>
			<tr>
			  <th>Description</th>
			  <td>
				Use BeanIgnore when you explicitly don't want to map a field.
				You can use this annotation on both sides.
			  </td>
			</tr>
		  </table>
		  <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Source {
    public Long id;
    public String name;
    @BeanIgnore
    public Integer age;
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
public class Target {
      @BeanIgnore
      public String name;
      public Integer age;
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Source source = new Source(1L, "Henk", 42);
Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertNull(target.name);
assertNull(target.age);
</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beandefault">
        <h3 class="section-title">BeanDefault</h3>
        <div class="section-body">
		  <table class="table table-condensed">
			<tr>
			  <th>Annotation</th>
			  <td>@BeanDefault</td>
			</tr>
			<tr>
			  <th>Arguments</th>
			  <td>Value: the default value for the field if the mapped value is null</td>
			</tr>
			<tr>
			  <th>Description</th>
			  <td>
				Use BeanDefault when you want to set a default value when the mapped value is null.
				You can use this annotation on both sides.
			  </td>
			</tr>
		  </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Source {
    public Long id;
    public String name;
    @BeanDefault("5")
    public Integer age;
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
public class Target {
    @BeanDefault("Henk")
    public String name;
    public Integer age;
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Source source = new Source(null, null, null);
Target target = new BeanMapperBuilder()
        .build()
        .map(source, Target.class);

assertEquals(5, target.age, 0);
assertEquals("Henk", target.name);
</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beancollection">
        <h3 class="section-title">BeanCollection</h3>
        <div class="section-body">
		  <table class="table table-condensed">
			<tr>
			  <th>Annotation</th>
			  <td>@BeanCollection</td>
			</tr>
			<tr>
			  <th>Arguments</th>
			  <td>
				elementType: the target collection element type<br>
				beanCollectionUsage: determines how to deal with the target collection.
				Below the possible options where REUSE is the default option.
				<ul>
				  <li>CONSTRUCT: always reconstruct the target collection</li>
				  <li>REUSE: reuse the target collection if it exists; construct if not</li>
				  <li>CLEAR: call clear on the target collection if it exists; construct if not</li>
				</ul>
			  </td>
			</tr>
			<tr>
			  <th>Description</th>
			  <td>
				Use BeanCollection when you want to map a field of type Collection.
				BeanCollection is only necessary if the element type of the collection differs from the other collection element type.
				You can use this annotation on both sides.
			  </td>
			</tr>
		  </table>
		  <br>
		  <div class="row">
			<div class="col-xs-12 col-md-6">
<code>
public class Source {
    public Set&lt;Person> items;
}

public class Person {
    public Long id;
    public String name;
    public Integer age;

    public Person(Long id, String name, Integer age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}
</code>
			</div>
			<div class="col-xs-12 col-md-6">
<code>
public class Target {
    @BeanCollection(elementType = PersonResult.class, beanCollectionUsage = BeanCollectionUsage.REUSE)
    public List&lt;PersonResult> items;
}

public class PersonResult {
    public String name;
    public Integer age;
}
</code>
			</div>
			<div class="col-xs-12">
			  <br>
<code>
Source source = new Source();
source.items = new LinkedHashSet&lt;Person>();
source.items.add(new Person(1L, "Henk", 42));
source.items.add(new Person(2L, "Piet", 18));
source.items.add(new Person(3L, "Gijs", 67));

Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals(3, target.items.size(), 0);
assertEquals("Henk", target.items.get(0).name);
assertEquals("Piet", target.items.get(1).name);
assertEquals("Gijs", target.items.get(2).name);
</code>
			</div>
		  </div>
		</div>
      </section>
      <section id="beanconstruct">
        <h3 class="section-title">BeanConstruct</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanConstruct</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Value: string array with the names of the fields that must be passed in the target constructor</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanConstruct when you want to map a to a class without a no-args constructor.
                BeanConstruct uses his arguments to get the field values from the source class and pass these arguments to the target class constructor.
                You can use this annotation on both sides.
                However only BeanConstruct on the target side makes sense because that object has to be created.
              </td>
            </tr>
            <tr>
              <th>Exceptions</th>
              <td>
                BeanConstructException is thrown when no valid constructor can be found.
                BeanInstantiationException is thrown when BeanMapper cannot intiante the target class.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Person {
    public Long id;
    public String firstName;
    public String prefix;
    public String lastName;

    public Person(Long id, String firstName, String prefix, String lastName) {
        this.id = id;
        this.firstName = firstName;
        this.prefix = prefix;
        this.lastName = lastName;
    }
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
@BeanConstruct({"firstName", "prefix", "lastName"})
public class PersonResult {
    public String fullName;

    public PersonResult(String name1, String name2, String name3) {
        this.fullName = name1 + " " + name2 + " " + name3;
    }
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Person person = new Person(1L, "Henk", "de", "Vries");

PersonResult target = new BeanMapperBuilder().build()
        .map(person, PersonResult.class);

assertEquals("Henk de Vries", target.fullName);
</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beanalias">
        <h3 class="section-title">BeanAlias</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanAlias</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Value: the name under which the field must be available</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanAlias when want to make a field available under a given name during the mapping process.
                This can be useful when using fields on a different level in BeanConstruct.
                This annotations can be used only at source side because you can make fields available from the source with another name for the target.
                BeanAlias differs from BeanProperty because BeanProperty is only available on the level where the field exist
                where BeanAlias is available on all mapping levels.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Source {
    public Long id;
    @BeanAlias("otherName")
    public String name;

    public Source(Long id, String name) {
        this.id = id;
        this.name = name;
    }
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
public class Target {
    public String otherName;
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Source source = new Source(1L, "Henk");

Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals("Henk", target.otherName);
</code>
            </div>
          </div>
        </div>
      </section>

      <!-- Nested -->
      <section id="nested-to-nested">
        <h3 class="section-title">Nested to Nested</h3>
        <div class="section-body">
          BeanMapper does support by default nested objects.
          Nested in this context means fields that have more fields inside.
          For example a pet. A pet does have name, birthDate and a type.
          Type is an instance of PetType which contains a name.
          If you want to map that pet you may also want to map the type inside the pet class.
          To indicate which classes are custom nested class (not String, Object etc.) you must set a package.
          All classes in the given package and sub-packages are eligible for mapping.
          The root source and target do not need to be set as such,
          because the verification is only run against nested classes which should be mapped implicitly as well.
          Below a example which is showing this use case.
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>
public class Pet {
    public String nickname;
    public LocalDate birthDate;
    public PetType type;

    public Pet(String nickname, LocalDate birthDate, Long typeId, String typeName) {
        this.nickname = nickname;
        this.birthDate = birthDate;
        this.type = new PetType();
        this.type.name = typeName;
        this.type.id = typeId;
    }
}

public class PetType {
    public Long id;
    public String name;
}
</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>
public class PetResult {
    @BeanProperty(name = "nickname")
    public String name;
    public PetTypeResult type;
}

public class PetTypeResult {
    public String name;
}
</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>
Pet pet = new Pet("Loebas", LocalDate.now(), 1L, "Dog");

PetResult petResult = new BeanMapperBuilder()
        .addPackagePrefix(PetTypeResult.class)
        .build()
        .map(pet, PetResult.class);

assertEquals("Loebas", petResult.name);
// Class PetType in Pet is mapped as well to PetTypeResult
assertEquals("Dog", petResult.type.name);
</code>
            </div>
          </div>
        </div>
      </section>
      <section id="nested-to-flat">
        <h3 class="section-title">Nested to Flat</h3>
        <div class="section-body"></div>
      </section>
      <section id="flat-to-nested">
        <h3 class="section-title">Flat to Nested</h3>
        <div class="section-body"></div>
      </section>

      <!-- REST -->
      <section id="get">
        <h3 class="section-title">GET</h3>
        <div class="section-body"></div>
      </section>
      <section id="post">
        <h3 class="section-title">POST</h3>
        <div class="section-body"></div>
      </section>
      <section id="put">
        <h3 class="section-title">PUT</h3>
        <div class="section-body"></div>
      </section>
      <section id="patch">
        <h3 class="section-title">PATCH</h3>
        <div class="section-body"></div>
      </section>
      <section id="delete">
        <h3 class="section-title">DELETE</h3>
        <div class="section-body"></div>
      </section>

    </div> <!-- End content column -->


    <div class="col-xs-hidden col-sm-3">
      <div id="menu">
        <div class="panel panel-default">
          <div class="panel-heading">
            <span class="panel-title">BeanMapper</span>
          </div>
          <div class="list-group">
            <a href="#about" class="list-group-item">About</a>
            <a href="#use-case" class="list-group-item">Use case</a>
            <a href="#how-to-use" class="list-group-item">How to Use</a>
            <a href="#download" class="list-group-item">Download</a>
          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading">
            <span class="panel-title">Different structure</span>
          </div>
          <div class="list-group">
            <a href="#beanproperty" class="list-group-item">Different names</a>
            <a href="#beanignore" class="list-group-item">Ignore fields</a>
            <a href="#beandefault" class="list-group-item">Default value for fields</a>
            <a href="#beancollection" class="list-group-item">Collection fields</a>
            <a href="#beanconstruct" class="list-group-item">No no-args constructor</a>
            <a href="#beanalias" class="list-group-item">Aliases</a>
          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading">
            <span class="panel-title">Nested structure</span>
          </div>
          <div class="list-group">
            <a href="#nested-to-nested" class="list-group-item">Nested to nested</a>
            <a href="#nested-to-flat" class="list-group-item">Nested to flat</a>
            <a href="#flat-to-nested" class="list-group-item">Flat to nested</a>
          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading">
            <span class="panel-title">REST</span>
          </div>
          <div class="list-group">
            <a href="#get" class="list-group-item">GET</a>
            <a href="#post" class="list-group-item">POST</a>
            <a href="#put" class="list-group-item">PUT</a>
            <a href="#patch" class="list-group-item">PATCH</a>
            <a href="#delete" class="list-group-item">DELETE</a>
          </div>
        </div>
      </div>
    </div> <!-- End menu column -->

  </div> <!-- End row -->
</div> <!-- End container -->

<script src="node_modules/jquery/dist/jquery.min.js"></script>
<script src="node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="scripts/highlight.pack.js"></script>
<script src="scripts/main.js"></script>

</body>
</html>