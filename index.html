<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">

  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">

  <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="styles/highlight.css">
  <link rel="stylesheet" href="styles/main.css">

  <title>Beanmapper by 42BV</title>
</head>

<body>

<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">BeanMapper</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://github.com/42BV/beanmapper/zipball/master"><i class="fa fa-arrow-circle-down"></i> Download as .zip</a></li>
        <li><a href="https://github.com/42BV/beanmapper/tarball/master"><i class="fa fa-arrow-circle-down"></i> Download as .tar.gz</a></li>
        <li><a href="https://github.com/42BV/beanmapper" target="_blank"><i class="fa fa-github"></i> View on GitHub</a></li>
      </ul>
    </div>
  </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-sm-3 sidebar">
      <ul class="nav nav-sidebar">
        <li class="li-heading">BeanMapper</li>
        <li><a href="#about">About</a></li>
        <li><a href="#use-case">Use case</a></li>
        <li><a href="#how-to-use">How to Use</a></li>
        <li><a href="#download">Download</a></li>
      </ul>
      <ul class="nav nav-sidebar">
        <li class="li-heading">Different structure</li>
        <li><a href="#beanproperty">Different names</a></li>
        <li><a href="#beanignore">Ignore fields</a></li>
        <li><a href="#beandefault">Default value for fields</a></li>
        <li><a href="#beancollection">Collection fields</a></li>
        <li><a href="#beanconstruct">No no-args constructor</a></li>
        <li><a href="#beanalias">Aliases</a></li>
        <li><a href="#beanconverter">Converters</a></li>
      </ul>
      <ul class="nav nav-sidebar">
        <li class="li-heading">Nested structure</li>
        <li><a href="#nested-to-nested">Nested to nested</a></li>
        <li><a href="#nested-to-flat">Nested to flat</a></li>
        <li><a href="#flat-to-nested">Flat to nested</a></li>
      </ul>
      <ul class="nav nav-sidebar">
        <li class="li-heading">REST</li>
        <li><a href="#get">GET request</a></li>
        <li><a href="#post">POST request</a></li>
        <li><a href="#put">PUT request</a></li>
        <li><a href="#patch">PATCH request</a></li>
        <li><a href="#delete">DELETE request</a></li>
      </ul>
    </div>
    <div class="col-sm-9 col-sm-offset-3 main">

      <h1 class="page-header text-center">
        <img src="images/logo.png" alt="Logo BeanMapper" width="100">
        Beanmapper
        <br>
        <small>Library for converting from one Java class to a dissimilar Java class <br>with similar names based on the Bean
          convention</small>
      </h1>

      <!-- BeanMapper -->
      <section id="about">
        <h3 class="section-title">What is BeanMapper?</h3>
        <div class="section-body">
          The core definition of the task of BeanMapper is for converting from one Java class to a dissimilar Java class with similar names based on the Bean convention.
          BeanMapper does not transform your objects. It copies all the values of the fields from an object to another object.
          You can configure the way BeanMapper should match te fields with annotations.
          However BeanMapper does have a lot more functionality than only converting Java classes.<br>
          You can read about this in the rest of the documentation.<br>
          <br>
          Using Spring?<br>
          Take a look at <a href="https://github.com/42BV/beanmapper-spring" target="_blank">BeanMapper-Spring</a> for combining the power of BeanMapper together with Spring.
          Scroll down to the <a href="#get">REST examples</a>  for usage with BeanMapper-Spring.
          <br>
          <br>
          Take a look at the <a href="https://github.com/42BV/beanmapper-petshop" target="_blank">BeanMapper-Petshop</a> for samples of using BeanMapper.
          It shows you how to use the BeanMapper in a REST API in Java.
          It also show examples of using BeanMapper in combination with BeanMapper-Spring.
          All examples shown in this documentation are based on this example project.
        </div>
      </section>
      <section id="use-case">
        <h3 class="section-title">Why using BeanMapper?</h3>
        <div class="section-body">
          When building a REST API you work quite often with three kinds of objects.
          <ol>
            <li>The Entity; The entity represents the data inside the application.</li>
            <li>The Result; The result represents the entity to the outside of the world. This could be a partially entity.</li>
            <li>The Form; When creating/updating a entity you often want to use a form object to pass the given data to.</li>
          </ol>
          Below a image showing this three objects in context of the application: <br>
          <a href="/images/beanmapper-usecase.png" target="_blank"><img src="images/beanmapper-usecase.png" height="200px"></a><br>

          <b>Why using forms?</b>
          <ul>
            <li>For security reasons you want to accept only a limited number of fields as input.</li>
            <li>The form fields are simplified to support frontend processing.</li>
          </ul>

          <b>Why using results?</b>
          <ul>
            <li>You want to simplify the result for frontend processing.</li>
            <li>You want to expose a limited number of fields for security reasons.</li>
          </ul>

          When using these three kinds of objects you want to convert incoming data to your entity. You also want to convert your entity to a result when representing data to the outside.
          These conversions will cost a lot of unnecessary code.<br>
          <br>
          <b>Wouldn't it be great if mapping from Form to Entity and from Entity to Result can be done automatically?</b><br>
          Let us suppose we have a tool that is able to map similar fields from dissimilar classes.<br>
          In this case, it would be just a matter of passing both instances and delegating the task of mapping from source to target to this tool.<br>
          This is why you should use BeanMapper; BeanMapper just does the above described problem in a very easy way.<br>
          Want to use BeanMapper? In the <a href="#how-to-use">next section</a>  you can read about using BeanMapper.<br>
          <br>
          For a more detailed use case of why using BeanMapper,
          read this blog <a href="http://dontpanic.42.nl/2016/02/the-case-for-beanmapper.html" target="_blank">'The Case for BeanMapper'</a>.<br>
        </div>
      </section>
      <section id="how-to-use">
        <h3 class="section-title">How to Use</h3>
        <div class="section-body">
          You can convert your objects on four different ways.
          <ol>
            <li>convert to a new class</li>
            <li>convert to a existing instance</li>
            <li>convert to a collection</li>
            <li>convert to a dynamic generated class</li>
          </ol>
          Below a basic sample of each way of converting. These samples only show a basic conversion.
          You should take a look at the rest of the documentation if you want to map some different fields or a map a different structure.<br>
          <br>
          Lets assume that we have two classes. SourceClass is your entity that is used inside the application.
          TargetClass is the class that you would like to expose to the outside.<br>
          <br>
          <code>public class Source {
    public Long id;
    public String name;
    public Integer age;

    public Source(Long id, String name, Integer age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}

public class Target {
    public String name;
    public Integer age;
}</code>
          <br><b>Map to a new class</b><br>
          Mapping to a new class does first create an instance of the given target class.<br>
          Then BeanMapper uses the map to existing instance strategy to map the source to the created class instance.<br>
          Take a look at <a href="#beanconstruct">BeanConstruct</a>  if you do not have a non-args constructor.<br>
          <br>
          <code>Source source = new Source(1L, "Henk", 42);

Target target = new BeanMapperBuilder().build()
    .map(source, Target.class);

assertEquals("Henk", target.name);
assertEquals(42, target.age, 0);</code>

          <br><b>Map to a existing instance</b><br>
          Use this method if you want to override a instance with another instance.<br>
          The values of the target instance are overwritten by the given source instance.<br>
          Fields are mapped base on the name of the field and based on bean conventions.
          BeanMapper only maps fields when a field name in the source instance matches a field name in the target instance.<br>
          With annotations you have a lot more possibilities to map classes, take a look on the list below.<br>
          <br>
          <table class="table table-condensed">
            <tr>
              <th>BeanIgnore</th>
              <td>Use this when you explicitly don't want to map a field.</td>
              <td><a href="#beanignore">docs</a></td>
            </tr>
            <tr>
              <th>BeanProperty</th>
              <td>Use this when you want to map fields that have no matching field names.</td>
              <td><a href="#beanproperty">docs</a></td>
            </tr>
            <tr>
              <th>BeanDefault</th>
              <td>Use this when you want to set a default value when the mapped value is null.</td>
              <td><a href="#beandefault">docs</a></td>
            </tr>
            <tr>
              <th>BeanCollection</th>
              <td>Use this when you want to map a field of type Collection.</td>
              <td><a href="#beancollection">docs</a></td>
            </tr>
          </table>
          <code>Source source = new Source(1L, "Henk", 42);

Target target = new BeanMapperBuilder().build()
    .map(source, Target.class);

assertEquals("Henk", target.name);
assertEquals(42, target.age, 0);</code>
          <br><b>Map to a collection</b><br>
          Use this method when you want to map a collection of items to a collection of items of an other type.<br>
          Of course you can do this for yourself by creating a loop and call map inside each loop.
          This method is just to make it easy for you.
          Can also pass a third optional argument to convert the list to. In this case we choose a ArrayList.class.<br>
          <br>
          <code>List&lt;Source> sources = new ArrayList&lt;Source>();
sources.add(new Source(1L, "Henk", 42));
sources.add(new Source(2L, "Piet", 50));
sources.add(new Source(3L, "Kees", 3));

ArrayList&lt;Target> targets = (ArrayList&lt;Target>) new BeanMapperBuilder().build()
    .map(sources, Target.class, ArrayList.class);

assertEquals(3, targets.size(), 0);
assertEquals("Henk", targets.get(0).name);
assertEquals("Piet", targets.get(1).name);
assertEquals("Kees", targets.get(2).name);</code>
          <br><b>Convert to a dynamic generated class</b><br>
          This method consist of two different ways:
          <ol>
            <li>Map only a few fields of the source class over the existing target instance.</li>
            <li>Map to a new target instance and restrict this target instance to contain only the given fields.</li>
          </ol>
          Both methods does use javassist to create a new class.
          <br><br>
          The first option is called 'downsizeSource'.
          This method generates a new class based on the source class but only with the fields you want to map.
          BeanMapper uses the generated class to map over the existing given target instance.
          The result is that you have mapped only a few fields from the source over the target instance.
          Use case for this method is for example a <a href="#patch">PATCH request</a>.
          <br><br>
          The second options is called 'downsizeTarget'.
          With this option you can expose a few fields of the source class to the outside.
          BeanMapper generates a new class based on the given target class but only with the fields you want to exist in the target.
          <br><br>
          Below examples of both options.
          <code>// Option 1: downsizeSource
BeanMapper beanMapper = new BeanMapperBuilder().build();
Source source = new Source(1L, "Henk", 42);
Target target = new Target("Piet", 12);

beanMapper.wrapConfig()
    .downsizeSource(Arrays.asList("age"))
    .build()
    .map(source, target);

assertEquals("Piet", target.name);
assertEquals(42, target.age, 0);

// Option 2: downsizeTarget
BeanMapper beanMapper = new BeanMapperBuilder().build();
Source source = new Source(1L, "Henk", 42);

Object target = beanMapper.wrapConfig()
    .downsizeTarget(Arrays.asList("name"))
    .build()
    .map(source, Target.class);

String json = new ObjectMapper().writeValueAsString(target);
assertEquals("{\"name\":\"Henk\"}", json);</code>
        </div>
      </section>
      <section id="download">
        <h3 class="section-title">Download</h3>
        <div class="section-body">
          In order to use Beanmapper in your project, simple add the following Maven dependency.<br>
          <code>
&lt;dependency&gt;
    &lt;groupId&gt;io.beanmapper&lt;/groupId&gt;
    &lt;artifactId&gt;beanmapper&lt;/artifactId&gt;
    &lt;version&gt;{{version}}&lt;/version&gt;
&lt;/dependency&gt;
          </code>
          <br>
          Version is the latest version of BeanMapper
          <a href="https://maven-badges.herokuapp.com/maven-central/io.beanmapper/beanmapper" target="_blank"><img src="https://maven-badges.herokuapp.com/maven-central/io.beanmapper/beanmapper/badge.svg"></a><br>
          <br>
          You can find the javadoc for BeanMapper <a href="http://www.javadoc.io/doc/io.beanmapper/beanmapper" target="_blank">here</a>.<br>
          You can also <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?g=io.beanmapper&a=beanmapper&v=LATEST&r=central-proxy">download the latest jar</a> and include this in your project.
        </div>
      </section>

      <!-- Annotations -->
      <section id="beanproperty">
        <h3 class="section-title">BeanProperty</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanProperty</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Name: the name that matches the field name on the other side</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>Use BeanProperty if the field name does not match the other field name.
                You can use this annotation on both sides.
              </td>
            </tr>
            <tr>
              <th>Exceptions</th>
              <td>BeanNoSuchPropertyException is thrown when BeanMapper can not find a field with the given name</td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
              <code>public class Source {
    public Long id;
    public String name;
    @BeanProperty(name = "otherAge")
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
              <code>public class Target {
    @BeanProperty(name = "name")
    public String otherName;
    public Integer otherAge;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              <code>Source source = new Source(1L, "Henk", 42);
Target target = new BeanMapperBuilder().build()
    .map(source, Target.class);

assertEquals("Henk", target.otherName);
assertEquals(42, target.otherAge, 0);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beanignore">
        <h3 class="section-title">BeanIgnore</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanIgnore</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>None</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanIgnore when you explicitly don't want to map a field.
                You can use this annotation on both sides.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
              <code>public class Source {
    public Long id;
    public String name;
    @BeanIgnore
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
              <code>public class Target {
    @BeanIgnore
    public String name;
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              <code>Source source = new Source(1L, "Henk", 42);
Target target = new BeanMapperBuilder().build()
    .map(source, Target.class);

assertNull(target.name);
assertNull(target.age);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beandefault">
        <h3 class="section-title">BeanDefault</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanDefault</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Value: the default value for the field if the mapped value is null</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanDefault when you want to set a default value when the mapped value is null.
                You can use this annotation on both sides.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
              <code>public class Source {
    public Long id;
    public String name;
    @BeanDefault("5")
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
              <code>public class Target {
    @BeanDefault("Henk")
    public String name;
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              <code>Source source = new Source(null, null, null);
Target target = new BeanMapperBuilder()
    .build()
    .map(source, Target.class);

assertEquals(5, target.age, 0);
assertEquals("Henk", target.name);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beancollection">
        <h3 class="section-title">BeanCollection</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanCollection</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>
                elementType: the target collection element type<br>
                beanCollectionUsage: determines how to deal with the target collection.
                Below the possible options where REUSE is the default option.
                <ul>
                  <li>CONSTRUCT: always reconstruct the target collection</li>
                  <li>REUSE: reuse the target collection if it exists; construct if not</li>
                  <li>CLEAR: call clear on the target collection if it exists; construct if not</li>
                </ul>
              </td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanCollection when you want to map a field of type Collection.
                BeanCollection is only necessary if the element type of the collection differs from the other collection element type.
                You can use this annotation on both sides.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
              <code>public class Source {
    public Set&lt;Person> items;
}

public class Person {
    public Long id;
    public String name;
    public Integer age;

    public Person(Long id, String name, Integer age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
              <code>public class Target {
    @BeanCollection(elementType = PersonResult.class, beanCollectionUsage = BeanCollectionUsage.REUSE)
    public List&lt;PersonResult> items;
}

public class PersonResult {
    public String name;
    public Integer age;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              <code>Source source = new Source();
source.items = new LinkedHashSet&lt;Person>();
source.items.add(new Person(1L, "Henk", 42));
source.items.add(new Person(2L, "Piet", 18));
source.items.add(new Person(3L, "Gijs", 67));

Target target = new BeanMapperBuilder().build()
    .map(source, Target.class);

assertEquals(3, target.items.size(), 0);
assertEquals("Henk", target.items.get(0).name);
assertEquals("Piet", target.items.get(1).name);
assertEquals("Gijs", target.items.get(2).name);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beanconstruct">
        <h3 class="section-title">BeanConstruct</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanConstruct</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Value: string array with the names of the fields that must be passed in the target constructor</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanConstruct when you want to map a to a class without a no-args constructor.
                BeanConstruct uses his arguments to get the field values from the source class and pass these arguments to the target class constructor.
                You can use this annotation on both sides.
                However only BeanConstruct on the target side makes sense because that object has to be created.
              </td>
            </tr>
            <tr>
              <th>Exceptions</th>
              <td>
                BeanConstructException is thrown when no valid constructor can be found.
                BeanInstantiationException is thrown when BeanMapper cannot intiantate the target class.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
              <code>public class Person {
    public Long id;
    public String firstName;
    public String prefix;
    public String lastName;

    public Person(Long id, String firstName, String prefix, String lastName) {
        this.id = id;
        this.firstName = firstName;
        this.prefix = prefix;
        this.lastName = lastName;
    }
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
              <code>@BeanConstruct({"firstName", "prefix", "lastName"})
public class PersonResult {
    public String fullName;

    public PersonResult(String name1, String name2, String name3) {
        this.fullName = name1 + " " + name2 + " " + name3;
    }
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              <code>Person person = new Person(1L, "Henk", "de", "Vries");

PersonResult target = new BeanMapperBuilder().build()
    .map(person, PersonResult.class);

assertEquals("Henk de Vries", target.fullName);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="beanalias">
        <h3 class="section-title">BeanAlias</h3>
        <div class="section-body">
          <table class="table table-condensed">
            <tr>
              <th>Annotation</th>
              <td>@BeanAlias</td>
            </tr>
            <tr>
              <th>Arguments</th>
              <td>Value: the name under which the field must be available</td>
            </tr>
            <tr>
              <th>Description</th>
              <td>
                Use BeanAlias when want to make a field available under a given name during the mapping process.
                This can be useful when using fields on a different level in BeanConstruct.
                This annotations can be used only at source side because you can make fields available from the source with another name for the target.
                BeanAlias differs from BeanProperty because BeanProperty is only available on the level where the field exist
                where BeanAlias is available on all mapping levels.
              </td>
            </tr>
          </table>
          <br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>public class Source {
    public Long id;
    @BeanAlias("otherName")
    public String name;

    public Source(Long id, String name) {
        this.id = id;
        this.name = name;
    }
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>public class Target {
    public String otherName;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>Source source = new Source(1L, "Henk");

Target target = new BeanMapperBuilder().build()
        .map(source, Target.class);

assertEquals("Henk", target.otherName);</code>
            </div>
          </div>
        </div>
      </section>

      <section id="beanconverter">
        <h3 class="section-title">BeanConverters</h3>
        <div class="section-body">
          Implement AbstractConverter
          Use SimpleBeanConverter
        </div>
      </section>

      <!-- Nested -->
      <section id="nested-to-nested">
        <h3 class="section-title">Nested to Nested</h3>
        <div class="section-body">
          Let's start with an example of mapping nested objects:<br>
          <img src="images/nested-to-nested.png" alt="nested to nested mapping"><br>
          BeanMapper does support by default nested objects.
          Nested in this context means fields that have more fields inside.
          For example a pet. A pet does have a name, birthDate and a type.
          Type is an instance of PetType which contains an id and a name.
          If you want to map that pet you may also want to map the type inside the pet class.
          BeanMapper just do that.
          <br><br>
          To indicate which classes are mapped deeper inside, you have to set a package.
          All classes in the given package and sub-packages are eligible for mapping.
          The root source and target do not need to be set as such,
          because the verification is only run against nested classes which should be mapped implicitly as well.
          Below a example which is showing this use case.
          <br><br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>public class Pet {
    public String nickname;
    public LocalDate birthDate;
    public PetType type;

    public Pet(String nickname, LocalDate birthDate, Long typeId, String typeName) {
        this.nickname = nickname;
        this.birthDate = birthDate;
        this.type = new PetType();
        this.type.name = typeName;
        this.type.id = typeId;
    }
}

public class PetType {
    public Long id;
    public String name;
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>public class PetResult {
    @BeanProperty(name = "nickname")
    public String name;
    public PetTypeResult type;
}

public class PetTypeResult {
    public String name;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>Pet pet = new Pet("Loebas", LocalDate.now(), 1L, "Dog");

PetResult petResult = new BeanMapperBuilder()
        .addPackagePrefix(PetTypeResult.class)
        .build()
        .map(pet, PetResult.class);

assertEquals("Loebas", petResult.name);
// Class PetType in Pet is mapped as well to PetTypeResult
assertEquals("Dog", petResult.type.name);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="nested-to-flat">
        <h3 class="section-title">Nested to Flat</h3>
        <div class="section-body">
          In this example the objects to map does not match and does have a different structure.
          Below a example of this case. Take a look at the <a href="#flat-to-nested">next example</a> for mapping this example in reverse direction.<br>
          <img src="images/nested-to-flat.png" alt="nested to flat mapping"><br>

          This use case comes up if you want to simplify your result to the outside.
          Your source object contains a nested structure of different fields.
          You want to simplify that object and create an object that represent this object in an easy way to the outside.
          <br>
          This example shows a owner of a pet. The owner does have a name and a address.
          The nested address object contains several fields such as street, number and city.
          For simplicity you want only the name and the living place of the owner in your result.
          This result uses BeanConstruct which is documented <a href="#beanconstruct">here</a>.
          With the BeanProperty annotation you can dive into objects on the other side.
          In this example the annotation references address.city.
          BeanMapper goes to the address and gets the city from it to map it to the living place in OwnerResult.class.
          You can dive as deep as you want with BeanProperty.
          <br><br>
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>public class Owner {
    public String firstName;
    public String prefix;
    public String lastName;
    public Address address;

    public Owner(String firstName, String prefix, String lastName, Address address) {
        this.firstName = firstName;
        this.prefix = prefix;
        this.lastName = lastName;
        this.address = address;
    }
}

public class Address {
    public String street;
    public int number;
    public String city;

    public Address(String street, int number, String city) {
        this.street = street;
        this.number = number;
        this.city = city;
    }
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>@BeanConstruct({"firstName", "prefix", "lastName"})
public class OwnerResult {

    public String fullName;
    @BeanProperty(name = "address.city")
    public String livingPlace;

    public OwnerResult(String firstName, String prefix, String lastName) {
        this.fullName = firstName + " " + prefix + " " + lastName;
    }
}</code>
            </div>
            <div class="col-xs-12">
              <br>
<code>Address address = new Address("hondstraat", 42, "Zoetermeer");
Owner owner = new Owner("Gijs", "de", "Hond", address);
OwnerResult ownerResult = beanMapper.map(owner, OwnerResult.class);
assertEquals("Gijs de Hond", ownerResult.fullName);
assertEquals("Zoetermeer", ownerResult.livingPlace);</code>
            </div>
          </div>
        </div>
      </section>
      <section id="flat-to-nested">
        <h3 class="section-title">Flat to Nested</h3>
        <div class="section-body">
          <img src="images/flat-to-nested.png" alt="flat to nested mapping"><br>
          In this case you can use BeanUnwrap annotation.
          You want to use this annotation for example if you are mapping a form to a entity in your application.
          Your source object is flat and you want to convert this object to a more complex object in your application.<br>
          BeanUnwrap indicates that the fields inside the annoted field should be mapped at the same level as the annotation exist.
          With this annotation BeanMapper can match fields on a higher level your object structure.
          <div class="row">
            <div class="col-xs-12 col-md-6">
<code>public class PetForm {
    public String nickname;
    public LocalDate birthDate;
    public Pet.Sex sex;
    public String familyName;
}</code>
            </div>
            <div class="col-xs-12 col-md-6">
<code>public class Pet {
    public String nickname;
    public LocalDate birthDate;
    public Sex sex;
    @BeanUnwrap
    public PetType type;

    public enum Sex {
        MALE, FEMALE, NEUTRAL, HERMAPHRODITIC;
    }
}

public class PetType {
    public String type;
    public String familyName;
}</code>
            </div>
            <div class="col-xs-12">
              <br>
              If you want your annotations at the other side you can use BeanProperty instead of BeanUnwrap.
              Now you can annotate the source side.
              Below a example, in this case BeanProperty indicates that BeanMapper should look for a field named familyName in the object PetType.
              <br><br>
<code>public class PetForm {
    public String nickname;
    public LocalDate birthDate;
    public Pet.Sex sex;
    @BeanProperty(name = "type.familyName")
    public String familyName;
}</code>
              <br>
<code>PetForm petForm = new PetForm();
petForm.nickname = "Loebas";
petForm.birthDate = LocalDate.now();
petForm.sex = Pet.Sex.MALE;
petForm.familyName = "Canidae";

Pet pet = beanMapper.map(petForm, Pet.class);
assertEquals("Loebas", pet.nickname);
assertEquals(LocalDate.now(), pet.birthDate);
assertEquals(Pet.Sex.MALE, pet.sex);
assertEquals("Canidae", pet.type.familyName);</code>
            </div>
          </div>
        </div>
      </section>

      <!-- REST -->
      <section id="get">
        <h3 class="section-title">GET request</h3>
        <div class="section-body">
          <b>BeanMapper way & BeanMapper-Spring way</b><br>
          BeanMapper-Spring does not have a special kind of mapping for get requests.<br>
<code>// Some request mappings
public AddressResult findOne(Long id) {
    return beanMapper.map(addressService.findOne(id), AddressResult.class));
}</code>
        </div>
      </section>
      <section id="post">
        <h3 class="section-title">POST request</h3>
        <div class="section-body">
          <b>BeanMapper way</b><br>
<code>// Some request mappings
public AddressResult create(AddressForm addressForm) {
    Address newAddress = beanMapper.map(addressForm, Address.class);
    return beanMapper.map(addressService.save(newAddress), AddressResult.class));
}</code>
          <b>BeanMapper-Spring way</b>
<code>// Some request mappingsT)
public PetResult create(@MergedForm(value = PetForm.class) Pet pet) {
    return beanMapper.map(petService.save(pet), PetResult.class));
}</code>
        </div>
      </section>
      <section id="put">
        <h3 class="section-title">PUT request</h3>
        <div class="section-body">
          <b>BeanMapper way</b><br>
          <b>BeanMapper-Spring way</b>
<code>@RequestMapping(value = "/{id}", method = RequestMethod.PUT)
public PetResult update(@MergedForm(value = PetForm.class, mergeId = "id") Pet pet) {
    return beanMapper.map(petService.save(pet), PetResult.class);
}</code>
        </div>
      </section>
      <section id="patch">
        <h3 class="section-title">PATCH request</h3>
        <div class="section-body">
          <b>BeanMapper way</b><br>
          <b>BeanMapper-Spring way</b>
        </div>
      </section>
      <section id="delete">
        <h3 class="section-title">DELETE request</h3>
        <div class="section-body">
          <b>BeanMapper way</b><br>
          <b>BeanMapper-Spring way</b>
        </div>
      </section>
    </div>
  </div>
</div>

<script src="node_modules/jquery/dist/jquery.min.js"></script>
<script src="node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="scripts/highlight.pack.js"></script>
<script src="scripts/main.js"></script>

</body>
</html>